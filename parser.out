Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist funlist codeblock
Rule 2     codeblock -> stmlist
Rule 3     codeblock -> <empty>
Rule 4     declist -> dec declist
Rule 5     declist -> <empty>
Rule 6     dec -> dec_int
Rule 7     dec -> dec_arr
Rule 8     dec -> dec_mat
Rule 9     dec_int -> INT ID SC
Rule 10    dec_arr -> INT ID LBRACKET NUM RBRACKET SC
Rule 11    dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC
Rule 12    funlist -> fun funlist
Rule 13    funlist -> <empty>
Rule 14    fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
Rule 15    fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY
Rule 16    idlist -> ID cont
Rule 17    idlist -> <empty>
Rule 18    cont -> COMMA ID cont
Rule 19    cont -> <empty>
Rule 20    stmlist -> stmt stmlist
Rule 21    stmlist -> stmt
Rule 22    stmt -> PRINTI LPAREN exprl RPAREN SC
Rule 23    stmt -> PRINTLN LPAREN RPAREN SC
Rule 24    stmt -> PRINTS LPAREN STRING RPAREN SC
Rule 25    stmt -> WHILE LPAREN exprl RPAREN block
Rule 26    stmt -> ID ASSIGN exprl SC
Rule 27    stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC
Rule 28    stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
Rule 29    stmt -> IF LPAREN exprl RPAREN block ELSE block
Rule 30    stmt -> IF LPAREN exprl RPAREN block
Rule 31    stmt -> INPUT LPAREN RPAREN SC
Rule 32    stmt -> exprl SC
Rule 33    block -> LCURLY stmlist RCURLY
Rule 34    block -> LCURLY stmt RCURLY
Rule 35    block -> stmt
Rule 36    exprl -> expr oprl exprl
Rule 37    exprl -> expr
Rule 38    expr -> expr opra term
Rule 39    expr -> term
Rule 40    term -> term oprm factor
Rule 41    term -> factor
Rule 42    factor -> LPAREN expr RPAREN
Rule 43    factor -> ID
Rule 44    factor -> NUM
Rule 45    factor -> NOT exprl
Rule 46    factor -> NEG exprl
Rule 47    factor -> ID LBRACKET exprl RBRACKET
Rule 48    factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
Rule 49    factor -> ATOI LPAREN argatoi RPAREN
Rule 50    factor -> ID LPAREN exprllist RPAREN
Rule 51    factor -> TRUE
Rule 52    factor -> FALSE
Rule 53    exprllist -> exprl contexprllist
Rule 54    exprllist -> <empty>
Rule 55    contexprllist -> COMMA exprl contexprllist
Rule 56    contexprllist -> <empty>
Rule 57    argatoi -> STRING
Rule 58    argatoi -> INPUT LPAREN RPAREN
Rule 59    opra -> ADD
Rule 60    opra -> SUBT
Rule 61    oprm -> MULT
Rule 62    oprm -> DIV
Rule 63    oprl -> EQ
Rule 64    oprl -> GEQ
Rule 65    oprl -> LEQ
Rule 66    oprl -> LT
Rule 67    oprl -> GT
Rule 68    oprl -> NEQ
Rule 69    oprl -> AND
Rule 70    oprl -> OR

Terminals, with rules where they appear

ADD                  : 59
AND                  : 69
ASSIGN               : 26 27 28
ATOI                 : 49
COMMA                : 18 55
DEF                  : 14 15
DIV                  : 62
ELSE                 : 29
EQ                   : 63
FALSE                : 52
GEQ                  : 64
GT                   : 67
ID                   : 9 10 11 14 15 16 18 26 27 28 43 47 48 50
IF                   : 29 30
INPUT                : 31 58
INT                  : 9 10 11 14
LBRACKET             : 10 11 11 27 28 28 47 48 48
LCURLY               : 14 15 33 34
LEQ                  : 65
LPAREN               : 14 15 22 23 24 25 29 30 31 42 49 50 58
LT                   : 66
MULT                 : 61
NEG                  : 46
NEQ                  : 68
NOT                  : 45
NUM                  : 10 11 11 44
OR                   : 70
PRINTI               : 22
PRINTLN              : 23
PRINTS               : 24
RBRACKET             : 10 11 11 27 28 28 47 48 48
RCURLY               : 14 15 33 34
RETURN               : 14 15
RPAREN               : 14 15 22 23 24 25 29 30 31 42 49 50 58
SC                   : 9 10 11 14 15 22 23 24 26 27 28 31 32
STRING               : 24 57
SUBT                 : 60
TRUE                 : 51
VOID                 : 15
WHILE                : 25
error                : 

Nonterminals, with rules where they appear

argatoi              : 49
block                : 25 29 29 30
codeblock            : 1
cont                 : 16 18
contexprllist        : 53 55
dec                  : 4
dec_arr              : 7
dec_int              : 6
dec_mat              : 8
declist              : 1 4
expr                 : 36 37 38 42
exprl                : 14 22 25 26 27 27 28 28 28 29 30 32 36 45 46 47 48 48 53 55
exprllist            : 50
factor               : 40 41
fun                  : 12
funlist              : 1 12
idlist               : 14 15
opra                 : 38
oprl                 : 36
oprm                 : 40
program              : 0
stmlist              : 2 14 15 20 33
stmt                 : 20 21 34 35
term                 : 38 39 40

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist funlist codeblock
    (4) declist -> . dec declist
    (5) declist -> .
    (6) dec -> . dec_int
    (7) dec -> . dec_arr
    (8) dec -> . dec_mat
    (9) dec_int -> . INT ID SC
    (10) dec_arr -> . INT ID LBRACKET NUM RBRACKET SC
    (11) dec_mat -> . INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC

    DEF             reduce using rule 5 (declist -> .)
    PRINTI          reduce using rule 5 (declist -> .)
    PRINTLN         reduce using rule 5 (declist -> .)
    PRINTS          reduce using rule 5 (declist -> .)
    WHILE           reduce using rule 5 (declist -> .)
    ID              reduce using rule 5 (declist -> .)
    IF              reduce using rule 5 (declist -> .)
    INPUT           reduce using rule 5 (declist -> .)
    LPAREN          reduce using rule 5 (declist -> .)
    NUM             reduce using rule 5 (declist -> .)
    NOT             reduce using rule 5 (declist -> .)
    NEG             reduce using rule 5 (declist -> .)
    ATOI            reduce using rule 5 (declist -> .)
    TRUE            reduce using rule 5 (declist -> .)
    FALSE           reduce using rule 5 (declist -> .)
    $end            reduce using rule 5 (declist -> .)
    INT             shift and go to state 7

    program                        shift and go to state 1
    declist                        shift and go to state 2
    dec                            shift and go to state 3
    dec_int                        shift and go to state 4
    dec_arr                        shift and go to state 5
    dec_mat                        shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . funlist codeblock
    (12) funlist -> . fun funlist
    (13) funlist -> .
    (14) fun -> . DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> . DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY

    PRINTI          reduce using rule 13 (funlist -> .)
    PRINTLN         reduce using rule 13 (funlist -> .)
    PRINTS          reduce using rule 13 (funlist -> .)
    WHILE           reduce using rule 13 (funlist -> .)
    ID              reduce using rule 13 (funlist -> .)
    IF              reduce using rule 13 (funlist -> .)
    INPUT           reduce using rule 13 (funlist -> .)
    LPAREN          reduce using rule 13 (funlist -> .)
    NUM             reduce using rule 13 (funlist -> .)
    NOT             reduce using rule 13 (funlist -> .)
    NEG             reduce using rule 13 (funlist -> .)
    ATOI            reduce using rule 13 (funlist -> .)
    TRUE            reduce using rule 13 (funlist -> .)
    FALSE           reduce using rule 13 (funlist -> .)
    $end            reduce using rule 13 (funlist -> .)
    DEF             shift and go to state 10

    funlist                        shift and go to state 8
    fun                            shift and go to state 9

state 3

    (4) declist -> dec . declist
    (4) declist -> . dec declist
    (5) declist -> .
    (6) dec -> . dec_int
    (7) dec -> . dec_arr
    (8) dec -> . dec_mat
    (9) dec_int -> . INT ID SC
    (10) dec_arr -> . INT ID LBRACKET NUM RBRACKET SC
    (11) dec_mat -> . INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC

    DEF             reduce using rule 5 (declist -> .)
    PRINTI          reduce using rule 5 (declist -> .)
    PRINTLN         reduce using rule 5 (declist -> .)
    PRINTS          reduce using rule 5 (declist -> .)
    WHILE           reduce using rule 5 (declist -> .)
    ID              reduce using rule 5 (declist -> .)
    IF              reduce using rule 5 (declist -> .)
    INPUT           reduce using rule 5 (declist -> .)
    LPAREN          reduce using rule 5 (declist -> .)
    NUM             reduce using rule 5 (declist -> .)
    NOT             reduce using rule 5 (declist -> .)
    NEG             reduce using rule 5 (declist -> .)
    ATOI            reduce using rule 5 (declist -> .)
    TRUE            reduce using rule 5 (declist -> .)
    FALSE           reduce using rule 5 (declist -> .)
    $end            reduce using rule 5 (declist -> .)
    INT             shift and go to state 7

    dec                            shift and go to state 3
    declist                        shift and go to state 11
    dec_int                        shift and go to state 4
    dec_arr                        shift and go to state 5
    dec_mat                        shift and go to state 6

state 4

    (6) dec -> dec_int .

    INT             reduce using rule 6 (dec -> dec_int .)
    DEF             reduce using rule 6 (dec -> dec_int .)
    PRINTI          reduce using rule 6 (dec -> dec_int .)
    PRINTLN         reduce using rule 6 (dec -> dec_int .)
    PRINTS          reduce using rule 6 (dec -> dec_int .)
    WHILE           reduce using rule 6 (dec -> dec_int .)
    ID              reduce using rule 6 (dec -> dec_int .)
    IF              reduce using rule 6 (dec -> dec_int .)
    INPUT           reduce using rule 6 (dec -> dec_int .)
    LPAREN          reduce using rule 6 (dec -> dec_int .)
    NUM             reduce using rule 6 (dec -> dec_int .)
    NOT             reduce using rule 6 (dec -> dec_int .)
    NEG             reduce using rule 6 (dec -> dec_int .)
    ATOI            reduce using rule 6 (dec -> dec_int .)
    TRUE            reduce using rule 6 (dec -> dec_int .)
    FALSE           reduce using rule 6 (dec -> dec_int .)
    $end            reduce using rule 6 (dec -> dec_int .)


state 5

    (7) dec -> dec_arr .

    INT             reduce using rule 7 (dec -> dec_arr .)
    DEF             reduce using rule 7 (dec -> dec_arr .)
    PRINTI          reduce using rule 7 (dec -> dec_arr .)
    PRINTLN         reduce using rule 7 (dec -> dec_arr .)
    PRINTS          reduce using rule 7 (dec -> dec_arr .)
    WHILE           reduce using rule 7 (dec -> dec_arr .)
    ID              reduce using rule 7 (dec -> dec_arr .)
    IF              reduce using rule 7 (dec -> dec_arr .)
    INPUT           reduce using rule 7 (dec -> dec_arr .)
    LPAREN          reduce using rule 7 (dec -> dec_arr .)
    NUM             reduce using rule 7 (dec -> dec_arr .)
    NOT             reduce using rule 7 (dec -> dec_arr .)
    NEG             reduce using rule 7 (dec -> dec_arr .)
    ATOI            reduce using rule 7 (dec -> dec_arr .)
    TRUE            reduce using rule 7 (dec -> dec_arr .)
    FALSE           reduce using rule 7 (dec -> dec_arr .)
    $end            reduce using rule 7 (dec -> dec_arr .)


state 6

    (8) dec -> dec_mat .

    INT             reduce using rule 8 (dec -> dec_mat .)
    DEF             reduce using rule 8 (dec -> dec_mat .)
    PRINTI          reduce using rule 8 (dec -> dec_mat .)
    PRINTLN         reduce using rule 8 (dec -> dec_mat .)
    PRINTS          reduce using rule 8 (dec -> dec_mat .)
    WHILE           reduce using rule 8 (dec -> dec_mat .)
    ID              reduce using rule 8 (dec -> dec_mat .)
    IF              reduce using rule 8 (dec -> dec_mat .)
    INPUT           reduce using rule 8 (dec -> dec_mat .)
    LPAREN          reduce using rule 8 (dec -> dec_mat .)
    NUM             reduce using rule 8 (dec -> dec_mat .)
    NOT             reduce using rule 8 (dec -> dec_mat .)
    NEG             reduce using rule 8 (dec -> dec_mat .)
    ATOI            reduce using rule 8 (dec -> dec_mat .)
    TRUE            reduce using rule 8 (dec -> dec_mat .)
    FALSE           reduce using rule 8 (dec -> dec_mat .)
    $end            reduce using rule 8 (dec -> dec_mat .)


state 7

    (9) dec_int -> INT . ID SC
    (10) dec_arr -> INT . ID LBRACKET NUM RBRACKET SC
    (11) dec_mat -> INT . ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC

    ID              shift and go to state 12


state 8

    (1) program -> declist funlist . codeblock
    (2) codeblock -> . stmlist
    (3) codeblock -> .
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    $end            reduce using rule 3 (codeblock -> .)
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    codeblock                      shift and go to state 13
    stmlist                        shift and go to state 14
    stmt                           shift and go to state 15
    exprl                          shift and go to state 18
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 9

    (12) funlist -> fun . funlist
    (12) funlist -> . fun funlist
    (13) funlist -> .
    (14) fun -> . DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> . DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY

    PRINTI          reduce using rule 13 (funlist -> .)
    PRINTLN         reduce using rule 13 (funlist -> .)
    PRINTS          reduce using rule 13 (funlist -> .)
    WHILE           reduce using rule 13 (funlist -> .)
    ID              reduce using rule 13 (funlist -> .)
    IF              reduce using rule 13 (funlist -> .)
    INPUT           reduce using rule 13 (funlist -> .)
    LPAREN          reduce using rule 13 (funlist -> .)
    NUM             reduce using rule 13 (funlist -> .)
    NOT             reduce using rule 13 (funlist -> .)
    NEG             reduce using rule 13 (funlist -> .)
    ATOI            reduce using rule 13 (funlist -> .)
    TRUE            reduce using rule 13 (funlist -> .)
    FALSE           reduce using rule 13 (funlist -> .)
    $end            reduce using rule 13 (funlist -> .)
    DEF             shift and go to state 10

    fun                            shift and go to state 9
    funlist                        shift and go to state 34

state 10

    (14) fun -> DEF . ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> DEF . ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY

    ID              shift and go to state 35


state 11

    (4) declist -> dec declist .

    DEF             reduce using rule 4 (declist -> dec declist .)
    PRINTI          reduce using rule 4 (declist -> dec declist .)
    PRINTLN         reduce using rule 4 (declist -> dec declist .)
    PRINTS          reduce using rule 4 (declist -> dec declist .)
    WHILE           reduce using rule 4 (declist -> dec declist .)
    ID              reduce using rule 4 (declist -> dec declist .)
    IF              reduce using rule 4 (declist -> dec declist .)
    INPUT           reduce using rule 4 (declist -> dec declist .)
    LPAREN          reduce using rule 4 (declist -> dec declist .)
    NUM             reduce using rule 4 (declist -> dec declist .)
    NOT             reduce using rule 4 (declist -> dec declist .)
    NEG             reduce using rule 4 (declist -> dec declist .)
    ATOI            reduce using rule 4 (declist -> dec declist .)
    TRUE            reduce using rule 4 (declist -> dec declist .)
    FALSE           reduce using rule 4 (declist -> dec declist .)
    $end            reduce using rule 4 (declist -> dec declist .)


state 12

    (9) dec_int -> INT ID . SC
    (10) dec_arr -> INT ID . LBRACKET NUM RBRACKET SC
    (11) dec_mat -> INT ID . LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC

    SC              shift and go to state 36
    LBRACKET        shift and go to state 37


state 13

    (1) program -> declist funlist codeblock .

    $end            reduce using rule 1 (program -> declist funlist codeblock .)


state 14

    (2) codeblock -> stmlist .

    $end            reduce using rule 2 (codeblock -> stmlist .)


state 15

    (20) stmlist -> stmt . stmlist
    (21) stmlist -> stmt .
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    $end            reduce using rule 21 (stmlist -> stmt .)
    RCURLY          reduce using rule 21 (stmlist -> stmt .)
    RETURN          reduce using rule 21 (stmlist -> stmt .)
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    stmt                           shift and go to state 15
    stmlist                        shift and go to state 38
    exprl                          shift and go to state 18
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 16

    (22) stmt -> PRINTI . LPAREN exprl RPAREN SC

    LPAREN          shift and go to state 39


state 17

    (42) factor -> LPAREN . expr RPAREN
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    expr                           shift and go to state 40
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 18

    (32) stmt -> exprl . SC

    SC              shift and go to state 42


state 19

    (23) stmt -> PRINTLN . LPAREN RPAREN SC

    LPAREN          shift and go to state 43


state 20

    (24) stmt -> PRINTS . LPAREN STRING RPAREN SC

    LPAREN          shift and go to state 44


state 21

    (25) stmt -> WHILE . LPAREN exprl RPAREN block

    LPAREN          shift and go to state 45


state 22

    (26) stmt -> ID . ASSIGN exprl SC
    (27) stmt -> ID . LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> ID . LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (43) factor -> ID .
    (47) factor -> ID . LBRACKET exprl RBRACKET
    (48) factor -> ID . LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (50) factor -> ID . LPAREN exprllist RPAREN

    ASSIGN          shift and go to state 46
    LBRACKET        shift and go to state 47
    MULT            reduce using rule 43 (factor -> ID .)
    DIV             reduce using rule 43 (factor -> ID .)
    EQ              reduce using rule 43 (factor -> ID .)
    GEQ             reduce using rule 43 (factor -> ID .)
    LEQ             reduce using rule 43 (factor -> ID .)
    LT              reduce using rule 43 (factor -> ID .)
    GT              reduce using rule 43 (factor -> ID .)
    NEQ             reduce using rule 43 (factor -> ID .)
    AND             reduce using rule 43 (factor -> ID .)
    OR              reduce using rule 43 (factor -> ID .)
    ADD             reduce using rule 43 (factor -> ID .)
    SUBT            reduce using rule 43 (factor -> ID .)
    SC              reduce using rule 43 (factor -> ID .)
    LPAREN          shift and go to state 48


state 23

    (29) stmt -> IF . LPAREN exprl RPAREN block ELSE block
    (30) stmt -> IF . LPAREN exprl RPAREN block

    LPAREN          shift and go to state 49


state 24

    (31) stmt -> INPUT . LPAREN RPAREN SC

    LPAREN          shift and go to state 50


state 25

    (36) exprl -> expr . oprl exprl
    (37) exprl -> expr .
    (38) expr -> expr . opra term
    (63) oprl -> . EQ
    (64) oprl -> . GEQ
    (65) oprl -> . LEQ
    (66) oprl -> . LT
    (67) oprl -> . GT
    (68) oprl -> . NEQ
    (69) oprl -> . AND
    (70) oprl -> . OR
    (59) opra -> . ADD
    (60) opra -> . SUBT

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUBT resolved as shift
    SC              reduce using rule 37 (exprl -> expr .)
    MULT            reduce using rule 37 (exprl -> expr .)
    DIV             reduce using rule 37 (exprl -> expr .)
    RPAREN          reduce using rule 37 (exprl -> expr .)
    RBRACKET        reduce using rule 37 (exprl -> expr .)
    COMMA           reduce using rule 37 (exprl -> expr .)
    EQ              shift and go to state 53
    GEQ             shift and go to state 54
    LEQ             shift and go to state 55
    LT              shift and go to state 56
    GT              shift and go to state 57
    NEQ             shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60
    ADD             shift and go to state 61
    SUBT            shift and go to state 62

  ! EQ              [ reduce using rule 37 (exprl -> expr .) ]
  ! GEQ             [ reduce using rule 37 (exprl -> expr .) ]
  ! LEQ             [ reduce using rule 37 (exprl -> expr .) ]
  ! LT              [ reduce using rule 37 (exprl -> expr .) ]
  ! GT              [ reduce using rule 37 (exprl -> expr .) ]
  ! NEQ             [ reduce using rule 37 (exprl -> expr .) ]
  ! AND             [ reduce using rule 37 (exprl -> expr .) ]
  ! OR              [ reduce using rule 37 (exprl -> expr .) ]
  ! ADD             [ reduce using rule 37 (exprl -> expr .) ]
  ! SUBT            [ reduce using rule 37 (exprl -> expr .) ]

    oprl                           shift and go to state 51
    opra                           shift and go to state 52

state 26

    (39) expr -> term .
    (40) term -> term . oprm factor
    (61) oprm -> . MULT
    (62) oprm -> . DIV

  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    EQ              reduce using rule 39 (expr -> term .)
    GEQ             reduce using rule 39 (expr -> term .)
    LEQ             reduce using rule 39 (expr -> term .)
    LT              reduce using rule 39 (expr -> term .)
    GT              reduce using rule 39 (expr -> term .)
    NEQ             reduce using rule 39 (expr -> term .)
    AND             reduce using rule 39 (expr -> term .)
    OR              reduce using rule 39 (expr -> term .)
    ADD             reduce using rule 39 (expr -> term .)
    SUBT            reduce using rule 39 (expr -> term .)
    SC              reduce using rule 39 (expr -> term .)
    RPAREN          reduce using rule 39 (expr -> term .)
    RBRACKET        reduce using rule 39 (expr -> term .)
    COMMA           reduce using rule 39 (expr -> term .)
    MULT            shift and go to state 64
    DIV             shift and go to state 65

  ! MULT            [ reduce using rule 39 (expr -> term .) ]
  ! DIV             [ reduce using rule 39 (expr -> term .) ]

    oprm                           shift and go to state 63

state 27

    (41) term -> factor .

    MULT            reduce using rule 41 (term -> factor .)
    DIV             reduce using rule 41 (term -> factor .)
    EQ              reduce using rule 41 (term -> factor .)
    GEQ             reduce using rule 41 (term -> factor .)
    LEQ             reduce using rule 41 (term -> factor .)
    LT              reduce using rule 41 (term -> factor .)
    GT              reduce using rule 41 (term -> factor .)
    NEQ             reduce using rule 41 (term -> factor .)
    AND             reduce using rule 41 (term -> factor .)
    OR              reduce using rule 41 (term -> factor .)
    ADD             reduce using rule 41 (term -> factor .)
    SUBT            reduce using rule 41 (term -> factor .)
    SC              reduce using rule 41 (term -> factor .)
    RPAREN          reduce using rule 41 (term -> factor .)
    RBRACKET        reduce using rule 41 (term -> factor .)
    COMMA           reduce using rule 41 (term -> factor .)


state 28

    (44) factor -> NUM .

    MULT            reduce using rule 44 (factor -> NUM .)
    DIV             reduce using rule 44 (factor -> NUM .)
    EQ              reduce using rule 44 (factor -> NUM .)
    GEQ             reduce using rule 44 (factor -> NUM .)
    LEQ             reduce using rule 44 (factor -> NUM .)
    LT              reduce using rule 44 (factor -> NUM .)
    GT              reduce using rule 44 (factor -> NUM .)
    NEQ             reduce using rule 44 (factor -> NUM .)
    AND             reduce using rule 44 (factor -> NUM .)
    OR              reduce using rule 44 (factor -> NUM .)
    ADD             reduce using rule 44 (factor -> NUM .)
    SUBT            reduce using rule 44 (factor -> NUM .)
    SC              reduce using rule 44 (factor -> NUM .)
    RPAREN          reduce using rule 44 (factor -> NUM .)
    RBRACKET        reduce using rule 44 (factor -> NUM .)
    COMMA           reduce using rule 44 (factor -> NUM .)


state 29

    (45) factor -> NOT . exprl
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 66
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 30

    (46) factor -> NEG . exprl
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 67
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 31

    (49) factor -> ATOI . LPAREN argatoi RPAREN

    LPAREN          shift and go to state 68


state 32

    (51) factor -> TRUE .

    MULT            reduce using rule 51 (factor -> TRUE .)
    DIV             reduce using rule 51 (factor -> TRUE .)
    EQ              reduce using rule 51 (factor -> TRUE .)
    GEQ             reduce using rule 51 (factor -> TRUE .)
    LEQ             reduce using rule 51 (factor -> TRUE .)
    LT              reduce using rule 51 (factor -> TRUE .)
    GT              reduce using rule 51 (factor -> TRUE .)
    NEQ             reduce using rule 51 (factor -> TRUE .)
    AND             reduce using rule 51 (factor -> TRUE .)
    OR              reduce using rule 51 (factor -> TRUE .)
    ADD             reduce using rule 51 (factor -> TRUE .)
    SUBT            reduce using rule 51 (factor -> TRUE .)
    SC              reduce using rule 51 (factor -> TRUE .)
    RPAREN          reduce using rule 51 (factor -> TRUE .)
    RBRACKET        reduce using rule 51 (factor -> TRUE .)
    COMMA           reduce using rule 51 (factor -> TRUE .)


state 33

    (52) factor -> FALSE .

    MULT            reduce using rule 52 (factor -> FALSE .)
    DIV             reduce using rule 52 (factor -> FALSE .)
    EQ              reduce using rule 52 (factor -> FALSE .)
    GEQ             reduce using rule 52 (factor -> FALSE .)
    LEQ             reduce using rule 52 (factor -> FALSE .)
    LT              reduce using rule 52 (factor -> FALSE .)
    GT              reduce using rule 52 (factor -> FALSE .)
    NEQ             reduce using rule 52 (factor -> FALSE .)
    AND             reduce using rule 52 (factor -> FALSE .)
    OR              reduce using rule 52 (factor -> FALSE .)
    ADD             reduce using rule 52 (factor -> FALSE .)
    SUBT            reduce using rule 52 (factor -> FALSE .)
    SC              reduce using rule 52 (factor -> FALSE .)
    RPAREN          reduce using rule 52 (factor -> FALSE .)
    RBRACKET        reduce using rule 52 (factor -> FALSE .)
    COMMA           reduce using rule 52 (factor -> FALSE .)


state 34

    (12) funlist -> fun funlist .

    PRINTI          reduce using rule 12 (funlist -> fun funlist .)
    PRINTLN         reduce using rule 12 (funlist -> fun funlist .)
    PRINTS          reduce using rule 12 (funlist -> fun funlist .)
    WHILE           reduce using rule 12 (funlist -> fun funlist .)
    ID              reduce using rule 12 (funlist -> fun funlist .)
    IF              reduce using rule 12 (funlist -> fun funlist .)
    INPUT           reduce using rule 12 (funlist -> fun funlist .)
    LPAREN          reduce using rule 12 (funlist -> fun funlist .)
    NUM             reduce using rule 12 (funlist -> fun funlist .)
    NOT             reduce using rule 12 (funlist -> fun funlist .)
    NEG             reduce using rule 12 (funlist -> fun funlist .)
    ATOI            reduce using rule 12 (funlist -> fun funlist .)
    TRUE            reduce using rule 12 (funlist -> fun funlist .)
    FALSE           reduce using rule 12 (funlist -> fun funlist .)
    $end            reduce using rule 12 (funlist -> fun funlist .)


state 35

    (14) fun -> DEF ID . LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> DEF ID . LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY

    LPAREN          shift and go to state 69


state 36

    (9) dec_int -> INT ID SC .

    INT             reduce using rule 9 (dec_int -> INT ID SC .)
    DEF             reduce using rule 9 (dec_int -> INT ID SC .)
    PRINTI          reduce using rule 9 (dec_int -> INT ID SC .)
    PRINTLN         reduce using rule 9 (dec_int -> INT ID SC .)
    PRINTS          reduce using rule 9 (dec_int -> INT ID SC .)
    WHILE           reduce using rule 9 (dec_int -> INT ID SC .)
    ID              reduce using rule 9 (dec_int -> INT ID SC .)
    IF              reduce using rule 9 (dec_int -> INT ID SC .)
    INPUT           reduce using rule 9 (dec_int -> INT ID SC .)
    LPAREN          reduce using rule 9 (dec_int -> INT ID SC .)
    NUM             reduce using rule 9 (dec_int -> INT ID SC .)
    NOT             reduce using rule 9 (dec_int -> INT ID SC .)
    NEG             reduce using rule 9 (dec_int -> INT ID SC .)
    ATOI            reduce using rule 9 (dec_int -> INT ID SC .)
    TRUE            reduce using rule 9 (dec_int -> INT ID SC .)
    FALSE           reduce using rule 9 (dec_int -> INT ID SC .)
    $end            reduce using rule 9 (dec_int -> INT ID SC .)


state 37

    (10) dec_arr -> INT ID LBRACKET . NUM RBRACKET SC
    (11) dec_mat -> INT ID LBRACKET . NUM RBRACKET LBRACKET NUM RBRACKET SC

    NUM             shift and go to state 70


state 38

    (20) stmlist -> stmt stmlist .

    $end            reduce using rule 20 (stmlist -> stmt stmlist .)
    RCURLY          reduce using rule 20 (stmlist -> stmt stmlist .)
    RETURN          reduce using rule 20 (stmlist -> stmt stmlist .)


state 39

    (22) stmt -> PRINTI LPAREN . exprl RPAREN SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 71
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 40

    (42) factor -> LPAREN expr . RPAREN
    (38) expr -> expr . opra term
    (59) opra -> . ADD
    (60) opra -> . SUBT

    RPAREN          shift and go to state 72
    ADD             shift and go to state 61
    SUBT            shift and go to state 62

    opra                           shift and go to state 52

state 41

    (43) factor -> ID .
    (47) factor -> ID . LBRACKET exprl RBRACKET
    (48) factor -> ID . LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (50) factor -> ID . LPAREN exprllist RPAREN

    MULT            reduce using rule 43 (factor -> ID .)
    DIV             reduce using rule 43 (factor -> ID .)
    RPAREN          reduce using rule 43 (factor -> ID .)
    ADD             reduce using rule 43 (factor -> ID .)
    SUBT            reduce using rule 43 (factor -> ID .)
    EQ              reduce using rule 43 (factor -> ID .)
    GEQ             reduce using rule 43 (factor -> ID .)
    LEQ             reduce using rule 43 (factor -> ID .)
    LT              reduce using rule 43 (factor -> ID .)
    GT              reduce using rule 43 (factor -> ID .)
    NEQ             reduce using rule 43 (factor -> ID .)
    AND             reduce using rule 43 (factor -> ID .)
    OR              reduce using rule 43 (factor -> ID .)
    SC              reduce using rule 43 (factor -> ID .)
    RBRACKET        reduce using rule 43 (factor -> ID .)
    COMMA           reduce using rule 43 (factor -> ID .)
    LBRACKET        shift and go to state 73
    LPAREN          shift and go to state 48


state 42

    (32) stmt -> exprl SC .

    PRINTI          reduce using rule 32 (stmt -> exprl SC .)
    PRINTLN         reduce using rule 32 (stmt -> exprl SC .)
    PRINTS          reduce using rule 32 (stmt -> exprl SC .)
    WHILE           reduce using rule 32 (stmt -> exprl SC .)
    ID              reduce using rule 32 (stmt -> exprl SC .)
    IF              reduce using rule 32 (stmt -> exprl SC .)
    INPUT           reduce using rule 32 (stmt -> exprl SC .)
    LPAREN          reduce using rule 32 (stmt -> exprl SC .)
    NUM             reduce using rule 32 (stmt -> exprl SC .)
    NOT             reduce using rule 32 (stmt -> exprl SC .)
    NEG             reduce using rule 32 (stmt -> exprl SC .)
    ATOI            reduce using rule 32 (stmt -> exprl SC .)
    TRUE            reduce using rule 32 (stmt -> exprl SC .)
    FALSE           reduce using rule 32 (stmt -> exprl SC .)
    $end            reduce using rule 32 (stmt -> exprl SC .)
    RCURLY          reduce using rule 32 (stmt -> exprl SC .)
    RETURN          reduce using rule 32 (stmt -> exprl SC .)
    ELSE            reduce using rule 32 (stmt -> exprl SC .)


state 43

    (23) stmt -> PRINTLN LPAREN . RPAREN SC

    RPAREN          shift and go to state 74


state 44

    (24) stmt -> PRINTS LPAREN . STRING RPAREN SC

    STRING          shift and go to state 75


state 45

    (25) stmt -> WHILE LPAREN . exprl RPAREN block
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 76
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 46

    (26) stmt -> ID ASSIGN . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 77
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 47

    (27) stmt -> ID LBRACKET . exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> ID LBRACKET . exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (47) factor -> ID LBRACKET . exprl RBRACKET
    (48) factor -> ID LBRACKET . exprl RBRACKET LBRACKET exprl RBRACKET
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 78
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 48

    (50) factor -> ID LPAREN . exprllist RPAREN
    (53) exprllist -> . exprl contexprllist
    (54) exprllist -> .
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    RPAREN          reduce using rule 54 (exprllist -> .)
    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprllist                      shift and go to state 79
    exprl                          shift and go to state 80
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 49

    (29) stmt -> IF LPAREN . exprl RPAREN block ELSE block
    (30) stmt -> IF LPAREN . exprl RPAREN block
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 81
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 50

    (31) stmt -> INPUT LPAREN . RPAREN SC

    RPAREN          shift and go to state 82


state 51

    (36) exprl -> expr oprl . exprl
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    expr                           shift and go to state 25
    exprl                          shift and go to state 83
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 52

    (38) expr -> expr opra . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    term                           shift and go to state 84
    factor                         shift and go to state 27

state 53

    (63) oprl -> EQ .

    LPAREN          reduce using rule 63 (oprl -> EQ .)
    ID              reduce using rule 63 (oprl -> EQ .)
    NUM             reduce using rule 63 (oprl -> EQ .)
    NOT             reduce using rule 63 (oprl -> EQ .)
    NEG             reduce using rule 63 (oprl -> EQ .)
    ATOI            reduce using rule 63 (oprl -> EQ .)
    TRUE            reduce using rule 63 (oprl -> EQ .)
    FALSE           reduce using rule 63 (oprl -> EQ .)


state 54

    (64) oprl -> GEQ .

    LPAREN          reduce using rule 64 (oprl -> GEQ .)
    ID              reduce using rule 64 (oprl -> GEQ .)
    NUM             reduce using rule 64 (oprl -> GEQ .)
    NOT             reduce using rule 64 (oprl -> GEQ .)
    NEG             reduce using rule 64 (oprl -> GEQ .)
    ATOI            reduce using rule 64 (oprl -> GEQ .)
    TRUE            reduce using rule 64 (oprl -> GEQ .)
    FALSE           reduce using rule 64 (oprl -> GEQ .)


state 55

    (65) oprl -> LEQ .

    LPAREN          reduce using rule 65 (oprl -> LEQ .)
    ID              reduce using rule 65 (oprl -> LEQ .)
    NUM             reduce using rule 65 (oprl -> LEQ .)
    NOT             reduce using rule 65 (oprl -> LEQ .)
    NEG             reduce using rule 65 (oprl -> LEQ .)
    ATOI            reduce using rule 65 (oprl -> LEQ .)
    TRUE            reduce using rule 65 (oprl -> LEQ .)
    FALSE           reduce using rule 65 (oprl -> LEQ .)


state 56

    (66) oprl -> LT .

    LPAREN          reduce using rule 66 (oprl -> LT .)
    ID              reduce using rule 66 (oprl -> LT .)
    NUM             reduce using rule 66 (oprl -> LT .)
    NOT             reduce using rule 66 (oprl -> LT .)
    NEG             reduce using rule 66 (oprl -> LT .)
    ATOI            reduce using rule 66 (oprl -> LT .)
    TRUE            reduce using rule 66 (oprl -> LT .)
    FALSE           reduce using rule 66 (oprl -> LT .)


state 57

    (67) oprl -> GT .

    LPAREN          reduce using rule 67 (oprl -> GT .)
    ID              reduce using rule 67 (oprl -> GT .)
    NUM             reduce using rule 67 (oprl -> GT .)
    NOT             reduce using rule 67 (oprl -> GT .)
    NEG             reduce using rule 67 (oprl -> GT .)
    ATOI            reduce using rule 67 (oprl -> GT .)
    TRUE            reduce using rule 67 (oprl -> GT .)
    FALSE           reduce using rule 67 (oprl -> GT .)


state 58

    (68) oprl -> NEQ .

    LPAREN          reduce using rule 68 (oprl -> NEQ .)
    ID              reduce using rule 68 (oprl -> NEQ .)
    NUM             reduce using rule 68 (oprl -> NEQ .)
    NOT             reduce using rule 68 (oprl -> NEQ .)
    NEG             reduce using rule 68 (oprl -> NEQ .)
    ATOI            reduce using rule 68 (oprl -> NEQ .)
    TRUE            reduce using rule 68 (oprl -> NEQ .)
    FALSE           reduce using rule 68 (oprl -> NEQ .)


state 59

    (69) oprl -> AND .

    LPAREN          reduce using rule 69 (oprl -> AND .)
    ID              reduce using rule 69 (oprl -> AND .)
    NUM             reduce using rule 69 (oprl -> AND .)
    NOT             reduce using rule 69 (oprl -> AND .)
    NEG             reduce using rule 69 (oprl -> AND .)
    ATOI            reduce using rule 69 (oprl -> AND .)
    TRUE            reduce using rule 69 (oprl -> AND .)
    FALSE           reduce using rule 69 (oprl -> AND .)


state 60

    (70) oprl -> OR .

    LPAREN          reduce using rule 70 (oprl -> OR .)
    ID              reduce using rule 70 (oprl -> OR .)
    NUM             reduce using rule 70 (oprl -> OR .)
    NOT             reduce using rule 70 (oprl -> OR .)
    NEG             reduce using rule 70 (oprl -> OR .)
    ATOI            reduce using rule 70 (oprl -> OR .)
    TRUE            reduce using rule 70 (oprl -> OR .)
    FALSE           reduce using rule 70 (oprl -> OR .)


state 61

    (59) opra -> ADD .

    LPAREN          reduce using rule 59 (opra -> ADD .)
    ID              reduce using rule 59 (opra -> ADD .)
    NUM             reduce using rule 59 (opra -> ADD .)
    NOT             reduce using rule 59 (opra -> ADD .)
    NEG             reduce using rule 59 (opra -> ADD .)
    ATOI            reduce using rule 59 (opra -> ADD .)
    TRUE            reduce using rule 59 (opra -> ADD .)
    FALSE           reduce using rule 59 (opra -> ADD .)


state 62

    (60) opra -> SUBT .

    LPAREN          reduce using rule 60 (opra -> SUBT .)
    ID              reduce using rule 60 (opra -> SUBT .)
    NUM             reduce using rule 60 (opra -> SUBT .)
    NOT             reduce using rule 60 (opra -> SUBT .)
    NEG             reduce using rule 60 (opra -> SUBT .)
    ATOI            reduce using rule 60 (opra -> SUBT .)
    TRUE            reduce using rule 60 (opra -> SUBT .)
    FALSE           reduce using rule 60 (opra -> SUBT .)


state 63

    (40) term -> term oprm . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    factor                         shift and go to state 85

state 64

    (61) oprm -> MULT .

    LPAREN          reduce using rule 61 (oprm -> MULT .)
    ID              reduce using rule 61 (oprm -> MULT .)
    NUM             reduce using rule 61 (oprm -> MULT .)
    NOT             reduce using rule 61 (oprm -> MULT .)
    NEG             reduce using rule 61 (oprm -> MULT .)
    ATOI            reduce using rule 61 (oprm -> MULT .)
    TRUE            reduce using rule 61 (oprm -> MULT .)
    FALSE           reduce using rule 61 (oprm -> MULT .)


state 65

    (62) oprm -> DIV .

    LPAREN          reduce using rule 62 (oprm -> DIV .)
    ID              reduce using rule 62 (oprm -> DIV .)
    NUM             reduce using rule 62 (oprm -> DIV .)
    NOT             reduce using rule 62 (oprm -> DIV .)
    NEG             reduce using rule 62 (oprm -> DIV .)
    ATOI            reduce using rule 62 (oprm -> DIV .)
    TRUE            reduce using rule 62 (oprm -> DIV .)
    FALSE           reduce using rule 62 (oprm -> DIV .)


state 66

    (45) factor -> NOT exprl .

    MULT            reduce using rule 45 (factor -> NOT exprl .)
    DIV             reduce using rule 45 (factor -> NOT exprl .)
    EQ              reduce using rule 45 (factor -> NOT exprl .)
    GEQ             reduce using rule 45 (factor -> NOT exprl .)
    LEQ             reduce using rule 45 (factor -> NOT exprl .)
    LT              reduce using rule 45 (factor -> NOT exprl .)
    GT              reduce using rule 45 (factor -> NOT exprl .)
    NEQ             reduce using rule 45 (factor -> NOT exprl .)
    AND             reduce using rule 45 (factor -> NOT exprl .)
    OR              reduce using rule 45 (factor -> NOT exprl .)
    ADD             reduce using rule 45 (factor -> NOT exprl .)
    SUBT            reduce using rule 45 (factor -> NOT exprl .)
    SC              reduce using rule 45 (factor -> NOT exprl .)
    RPAREN          reduce using rule 45 (factor -> NOT exprl .)
    RBRACKET        reduce using rule 45 (factor -> NOT exprl .)
    COMMA           reduce using rule 45 (factor -> NOT exprl .)


state 67

    (46) factor -> NEG exprl .

    MULT            reduce using rule 46 (factor -> NEG exprl .)
    DIV             reduce using rule 46 (factor -> NEG exprl .)
    EQ              reduce using rule 46 (factor -> NEG exprl .)
    GEQ             reduce using rule 46 (factor -> NEG exprl .)
    LEQ             reduce using rule 46 (factor -> NEG exprl .)
    LT              reduce using rule 46 (factor -> NEG exprl .)
    GT              reduce using rule 46 (factor -> NEG exprl .)
    NEQ             reduce using rule 46 (factor -> NEG exprl .)
    AND             reduce using rule 46 (factor -> NEG exprl .)
    OR              reduce using rule 46 (factor -> NEG exprl .)
    ADD             reduce using rule 46 (factor -> NEG exprl .)
    SUBT            reduce using rule 46 (factor -> NEG exprl .)
    SC              reduce using rule 46 (factor -> NEG exprl .)
    RPAREN          reduce using rule 46 (factor -> NEG exprl .)
    RBRACKET        reduce using rule 46 (factor -> NEG exprl .)
    COMMA           reduce using rule 46 (factor -> NEG exprl .)


state 68

    (49) factor -> ATOI LPAREN . argatoi RPAREN
    (57) argatoi -> . STRING
    (58) argatoi -> . INPUT LPAREN RPAREN

    STRING          shift and go to state 87
    INPUT           shift and go to state 88

    argatoi                        shift and go to state 86

state 69

    (14) fun -> DEF ID LPAREN . idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> DEF ID LPAREN . idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY
    (16) idlist -> . ID cont
    (17) idlist -> .

    ID              shift and go to state 89
    RPAREN          reduce using rule 17 (idlist -> .)

    idlist                         shift and go to state 90

state 70

    (10) dec_arr -> INT ID LBRACKET NUM . RBRACKET SC
    (11) dec_mat -> INT ID LBRACKET NUM . RBRACKET LBRACKET NUM RBRACKET SC

    RBRACKET        shift and go to state 91


state 71

    (22) stmt -> PRINTI LPAREN exprl . RPAREN SC

    RPAREN          shift and go to state 92


state 72

    (42) factor -> LPAREN expr RPAREN .

    MULT            reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    DIV             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    ADD             reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    SUBT            reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    SC              reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 42 (factor -> LPAREN expr RPAREN .)


state 73

    (47) factor -> ID LBRACKET . exprl RBRACKET
    (48) factor -> ID LBRACKET . exprl RBRACKET LBRACKET exprl RBRACKET
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 93
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 74

    (23) stmt -> PRINTLN LPAREN RPAREN . SC

    SC              shift and go to state 94


state 75

    (24) stmt -> PRINTS LPAREN STRING . RPAREN SC

    RPAREN          shift and go to state 95


state 76

    (25) stmt -> WHILE LPAREN exprl . RPAREN block

    RPAREN          shift and go to state 96


state 77

    (26) stmt -> ID ASSIGN exprl . SC

    SC              shift and go to state 97


state 78

    (27) stmt -> ID LBRACKET exprl . RBRACKET ASSIGN exprl SC
    (28) stmt -> ID LBRACKET exprl . RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (47) factor -> ID LBRACKET exprl . RBRACKET
    (48) factor -> ID LBRACKET exprl . RBRACKET LBRACKET exprl RBRACKET

    RBRACKET        shift and go to state 98


state 79

    (50) factor -> ID LPAREN exprllist . RPAREN

    RPAREN          shift and go to state 99


state 80

    (53) exprllist -> exprl . contexprllist
    (55) contexprllist -> . COMMA exprl contexprllist
    (56) contexprllist -> .

    COMMA           shift and go to state 101
    RPAREN          reduce using rule 56 (contexprllist -> .)

    contexprllist                  shift and go to state 100

state 81

    (29) stmt -> IF LPAREN exprl . RPAREN block ELSE block
    (30) stmt -> IF LPAREN exprl . RPAREN block

    RPAREN          shift and go to state 102


state 82

    (31) stmt -> INPUT LPAREN RPAREN . SC

    SC              shift and go to state 103


state 83

    (36) exprl -> expr oprl exprl .

    SC              reduce using rule 36 (exprl -> expr oprl exprl .)
    MULT            reduce using rule 36 (exprl -> expr oprl exprl .)
    DIV             reduce using rule 36 (exprl -> expr oprl exprl .)
    EQ              reduce using rule 36 (exprl -> expr oprl exprl .)
    GEQ             reduce using rule 36 (exprl -> expr oprl exprl .)
    LEQ             reduce using rule 36 (exprl -> expr oprl exprl .)
    LT              reduce using rule 36 (exprl -> expr oprl exprl .)
    GT              reduce using rule 36 (exprl -> expr oprl exprl .)
    NEQ             reduce using rule 36 (exprl -> expr oprl exprl .)
    AND             reduce using rule 36 (exprl -> expr oprl exprl .)
    OR              reduce using rule 36 (exprl -> expr oprl exprl .)
    ADD             reduce using rule 36 (exprl -> expr oprl exprl .)
    SUBT            reduce using rule 36 (exprl -> expr oprl exprl .)
    RPAREN          reduce using rule 36 (exprl -> expr oprl exprl .)
    RBRACKET        reduce using rule 36 (exprl -> expr oprl exprl .)
    COMMA           reduce using rule 36 (exprl -> expr oprl exprl .)


state 84

    (38) expr -> expr opra term .
    (40) term -> term . oprm factor
    (61) oprm -> . MULT
    (62) oprm -> . DIV

  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    EQ              reduce using rule 38 (expr -> expr opra term .)
    GEQ             reduce using rule 38 (expr -> expr opra term .)
    LEQ             reduce using rule 38 (expr -> expr opra term .)
    LT              reduce using rule 38 (expr -> expr opra term .)
    GT              reduce using rule 38 (expr -> expr opra term .)
    NEQ             reduce using rule 38 (expr -> expr opra term .)
    AND             reduce using rule 38 (expr -> expr opra term .)
    OR              reduce using rule 38 (expr -> expr opra term .)
    ADD             reduce using rule 38 (expr -> expr opra term .)
    SUBT            reduce using rule 38 (expr -> expr opra term .)
    SC              reduce using rule 38 (expr -> expr opra term .)
    RPAREN          reduce using rule 38 (expr -> expr opra term .)
    RBRACKET        reduce using rule 38 (expr -> expr opra term .)
    COMMA           reduce using rule 38 (expr -> expr opra term .)
    MULT            shift and go to state 64
    DIV             shift and go to state 65

  ! MULT            [ reduce using rule 38 (expr -> expr opra term .) ]
  ! DIV             [ reduce using rule 38 (expr -> expr opra term .) ]

    oprm                           shift and go to state 63

state 85

    (40) term -> term oprm factor .

    MULT            reduce using rule 40 (term -> term oprm factor .)
    DIV             reduce using rule 40 (term -> term oprm factor .)
    EQ              reduce using rule 40 (term -> term oprm factor .)
    GEQ             reduce using rule 40 (term -> term oprm factor .)
    LEQ             reduce using rule 40 (term -> term oprm factor .)
    LT              reduce using rule 40 (term -> term oprm factor .)
    GT              reduce using rule 40 (term -> term oprm factor .)
    NEQ             reduce using rule 40 (term -> term oprm factor .)
    AND             reduce using rule 40 (term -> term oprm factor .)
    OR              reduce using rule 40 (term -> term oprm factor .)
    ADD             reduce using rule 40 (term -> term oprm factor .)
    SUBT            reduce using rule 40 (term -> term oprm factor .)
    SC              reduce using rule 40 (term -> term oprm factor .)
    RPAREN          reduce using rule 40 (term -> term oprm factor .)
    RBRACKET        reduce using rule 40 (term -> term oprm factor .)
    COMMA           reduce using rule 40 (term -> term oprm factor .)


state 86

    (49) factor -> ATOI LPAREN argatoi . RPAREN

    RPAREN          shift and go to state 104


state 87

    (57) argatoi -> STRING .

    RPAREN          reduce using rule 57 (argatoi -> STRING .)


state 88

    (58) argatoi -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 105


state 89

    (16) idlist -> ID . cont
    (18) cont -> . COMMA ID cont
    (19) cont -> .

    COMMA           shift and go to state 107
    RPAREN          reduce using rule 19 (cont -> .)

    cont                           shift and go to state 106

state 90

    (14) fun -> DEF ID LPAREN idlist . RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> DEF ID LPAREN idlist . RPAREN VOID LCURLY stmlist RETURN SC RCURLY

    RPAREN          shift and go to state 108


state 91

    (10) dec_arr -> INT ID LBRACKET NUM RBRACKET . SC
    (11) dec_mat -> INT ID LBRACKET NUM RBRACKET . LBRACKET NUM RBRACKET SC

    SC              shift and go to state 110
    LBRACKET        shift and go to state 109


state 92

    (22) stmt -> PRINTI LPAREN exprl RPAREN . SC

    SC              shift and go to state 111


state 93

    (47) factor -> ID LBRACKET exprl . RBRACKET
    (48) factor -> ID LBRACKET exprl . RBRACKET LBRACKET exprl RBRACKET

    RBRACKET        shift and go to state 112


state 94

    (23) stmt -> PRINTLN LPAREN RPAREN SC .

    PRINTI          reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    PRINTLN         reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    PRINTS          reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    WHILE           reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    ID              reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    IF              reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    INPUT           reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    LPAREN          reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    NUM             reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    NOT             reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    NEG             reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    ATOI            reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    TRUE            reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    FALSE           reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    $end            reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    RCURLY          reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    RETURN          reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)
    ELSE            reduce using rule 23 (stmt -> PRINTLN LPAREN RPAREN SC .)


state 95

    (24) stmt -> PRINTS LPAREN STRING RPAREN . SC

    SC              shift and go to state 113


state 96

    (25) stmt -> WHILE LPAREN exprl RPAREN . block
    (33) block -> . LCURLY stmlist RCURLY
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LCURLY          shift and go to state 115
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 18
    block                          shift and go to state 114
    stmt                           shift and go to state 116
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 97

    (26) stmt -> ID ASSIGN exprl SC .

    PRINTI          reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    PRINTLN         reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    PRINTS          reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    WHILE           reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    ID              reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    IF              reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    INPUT           reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    LPAREN          reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    NUM             reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    NOT             reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    NEG             reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    ATOI            reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    TRUE            reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    FALSE           reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    $end            reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    RCURLY          reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    RETURN          reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)
    ELSE            reduce using rule 26 (stmt -> ID ASSIGN exprl SC .)


state 98

    (27) stmt -> ID LBRACKET exprl RBRACKET . ASSIGN exprl SC
    (28) stmt -> ID LBRACKET exprl RBRACKET . LBRACKET exprl RBRACKET ASSIGN exprl SC
    (47) factor -> ID LBRACKET exprl RBRACKET .
    (48) factor -> ID LBRACKET exprl RBRACKET . LBRACKET exprl RBRACKET

    ASSIGN          shift and go to state 118
    LBRACKET        shift and go to state 117
    MULT            reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    DIV             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    EQ              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    GEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    LEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    LT              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    GT              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    NEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    AND             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    OR              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    ADD             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    SUBT            reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    SC              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)


state 99

    (50) factor -> ID LPAREN exprllist RPAREN .

    MULT            reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    DIV             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    EQ              reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    GEQ             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    LEQ             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    LT              reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    GT              reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    NEQ             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    AND             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    OR              reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    ADD             reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    SUBT            reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    SC              reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    RPAREN          reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    RBRACKET        reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)
    COMMA           reduce using rule 50 (factor -> ID LPAREN exprllist RPAREN .)


state 100

    (53) exprllist -> exprl contexprllist .

    RPAREN          reduce using rule 53 (exprllist -> exprl contexprllist .)


state 101

    (55) contexprllist -> COMMA . exprl contexprllist
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 119
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 102

    (29) stmt -> IF LPAREN exprl RPAREN . block ELSE block
    (30) stmt -> IF LPAREN exprl RPAREN . block
    (33) block -> . LCURLY stmlist RCURLY
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LCURLY          shift and go to state 115
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 18
    block                          shift and go to state 120
    stmt                           shift and go to state 116
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 103

    (31) stmt -> INPUT LPAREN RPAREN SC .

    PRINTI          reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    PRINTLN         reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    PRINTS          reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    WHILE           reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    ID              reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    IF              reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    INPUT           reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    LPAREN          reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    NUM             reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    NOT             reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    NEG             reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    ATOI            reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    TRUE            reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    FALSE           reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    $end            reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    RCURLY          reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    RETURN          reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)
    ELSE            reduce using rule 31 (stmt -> INPUT LPAREN RPAREN SC .)


state 104

    (49) factor -> ATOI LPAREN argatoi RPAREN .

    MULT            reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    DIV             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    EQ              reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    GEQ             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    LEQ             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    LT              reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    GT              reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    NEQ             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    AND             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    OR              reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    ADD             reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    SUBT            reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    SC              reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    RPAREN          reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    RBRACKET        reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)
    COMMA           reduce using rule 49 (factor -> ATOI LPAREN argatoi RPAREN .)


state 105

    (58) argatoi -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 121


state 106

    (16) idlist -> ID cont .

    RPAREN          reduce using rule 16 (idlist -> ID cont .)


state 107

    (18) cont -> COMMA . ID cont

    ID              shift and go to state 122


state 108

    (14) fun -> DEF ID LPAREN idlist RPAREN . INT LCURLY stmlist RETURN exprl SC RCURLY
    (15) fun -> DEF ID LPAREN idlist RPAREN . VOID LCURLY stmlist RETURN SC RCURLY

    INT             shift and go to state 123
    VOID            shift and go to state 124


state 109

    (11) dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET . NUM RBRACKET SC

    NUM             shift and go to state 125


state 110

    (10) dec_arr -> INT ID LBRACKET NUM RBRACKET SC .

    INT             reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    DEF             reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    PRINTI          reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    PRINTLN         reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    PRINTS          reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    WHILE           reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    ID              reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    IF              reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    INPUT           reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    LPAREN          reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    NUM             reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    NOT             reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    NEG             reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    ATOI            reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    TRUE            reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    FALSE           reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)
    $end            reduce using rule 10 (dec_arr -> INT ID LBRACKET NUM RBRACKET SC .)


state 111

    (22) stmt -> PRINTI LPAREN exprl RPAREN SC .

    PRINTI          reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    PRINTLN         reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    PRINTS          reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    WHILE           reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    ID              reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    IF              reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    INPUT           reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    LPAREN          reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    NUM             reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    NOT             reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    NEG             reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    ATOI            reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    TRUE            reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    FALSE           reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    $end            reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    RCURLY          reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    RETURN          reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)
    ELSE            reduce using rule 22 (stmt -> PRINTI LPAREN exprl RPAREN SC .)


state 112

    (47) factor -> ID LBRACKET exprl RBRACKET .
    (48) factor -> ID LBRACKET exprl RBRACKET . LBRACKET exprl RBRACKET

    MULT            reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    DIV             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    RPAREN          reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    ADD             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    SUBT            reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    EQ              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    GEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    LEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    LT              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    GT              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    NEQ             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    AND             reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    OR              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    SC              reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    RBRACKET        reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    COMMA           reduce using rule 47 (factor -> ID LBRACKET exprl RBRACKET .)
    LBRACKET        shift and go to state 126


state 113

    (24) stmt -> PRINTS LPAREN STRING RPAREN SC .

    PRINTI          reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    PRINTLN         reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    PRINTS          reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    WHILE           reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    ID              reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    IF              reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    INPUT           reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    LPAREN          reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    NUM             reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    NOT             reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    NEG             reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    ATOI            reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    TRUE            reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    FALSE           reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    $end            reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    RCURLY          reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    RETURN          reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)
    ELSE            reduce using rule 24 (stmt -> PRINTS LPAREN STRING RPAREN SC .)


state 114

    (25) stmt -> WHILE LPAREN exprl RPAREN block .

    PRINTI          reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    PRINTLN         reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    PRINTS          reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    WHILE           reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    ID              reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    IF              reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    INPUT           reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    LPAREN          reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    NUM             reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    NOT             reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    NEG             reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    ATOI            reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    TRUE            reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    FALSE           reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    $end            reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    RCURLY          reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    RETURN          reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)
    ELSE            reduce using rule 25 (stmt -> WHILE LPAREN exprl RPAREN block .)


state 115

    (33) block -> LCURLY . stmlist RCURLY
    (34) block -> LCURLY . stmt RCURLY
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    stmlist                        shift and go to state 127
    stmt                           shift and go to state 128
    exprl                          shift and go to state 18
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 116

    (35) block -> stmt .

    PRINTI          reduce using rule 35 (block -> stmt .)
    PRINTLN         reduce using rule 35 (block -> stmt .)
    PRINTS          reduce using rule 35 (block -> stmt .)
    WHILE           reduce using rule 35 (block -> stmt .)
    ID              reduce using rule 35 (block -> stmt .)
    IF              reduce using rule 35 (block -> stmt .)
    INPUT           reduce using rule 35 (block -> stmt .)
    LPAREN          reduce using rule 35 (block -> stmt .)
    NUM             reduce using rule 35 (block -> stmt .)
    NOT             reduce using rule 35 (block -> stmt .)
    NEG             reduce using rule 35 (block -> stmt .)
    ATOI            reduce using rule 35 (block -> stmt .)
    TRUE            reduce using rule 35 (block -> stmt .)
    FALSE           reduce using rule 35 (block -> stmt .)
    $end            reduce using rule 35 (block -> stmt .)
    RCURLY          reduce using rule 35 (block -> stmt .)
    RETURN          reduce using rule 35 (block -> stmt .)
    ELSE            reduce using rule 35 (block -> stmt .)


state 117

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET . exprl RBRACKET ASSIGN exprl SC
    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET . exprl RBRACKET
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 129
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 118

    (27) stmt -> ID LBRACKET exprl RBRACKET ASSIGN . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 130
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 119

    (55) contexprllist -> COMMA exprl . contexprllist
    (55) contexprllist -> . COMMA exprl contexprllist
    (56) contexprllist -> .

    COMMA           shift and go to state 101
    RPAREN          reduce using rule 56 (contexprllist -> .)

    contexprllist                  shift and go to state 131

state 120

    (29) stmt -> IF LPAREN exprl RPAREN block . ELSE block
    (30) stmt -> IF LPAREN exprl RPAREN block .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 132
    PRINTI          reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    PRINTLN         reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    PRINTS          reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    WHILE           reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    ID              reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    IF              reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    INPUT           reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    LPAREN          reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    NUM             reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    NOT             reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    NEG             reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    ATOI            reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    TRUE            reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    FALSE           reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    $end            reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    RCURLY          reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)
    RETURN          reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .)

  ! ELSE            [ reduce using rule 30 (stmt -> IF LPAREN exprl RPAREN block .) ]


state 121

    (58) argatoi -> INPUT LPAREN RPAREN .

    RPAREN          reduce using rule 58 (argatoi -> INPUT LPAREN RPAREN .)


state 122

    (18) cont -> COMMA ID . cont
    (18) cont -> . COMMA ID cont
    (19) cont -> .

    COMMA           shift and go to state 107
    RPAREN          reduce using rule 19 (cont -> .)

    cont                           shift and go to state 133

state 123

    (14) fun -> DEF ID LPAREN idlist RPAREN INT . LCURLY stmlist RETURN exprl SC RCURLY

    LCURLY          shift and go to state 134


state 124

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID . LCURLY stmlist RETURN SC RCURLY

    LCURLY          shift and go to state 135


state 125

    (11) dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM . RBRACKET SC

    RBRACKET        shift and go to state 136


state 126

    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET . exprl RBRACKET
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 137
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 127

    (33) block -> LCURLY stmlist . RCURLY

    RCURLY          shift and go to state 138


state 128

    (34) block -> LCURLY stmt . RCURLY
    (20) stmlist -> stmt . stmlist
    (21) stmlist -> stmt .
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

  ! shift/reduce conflict for RCURLY resolved as shift
    RCURLY          shift and go to state 139
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

  ! RCURLY          [ reduce using rule 21 (stmlist -> stmt .) ]

    stmt                           shift and go to state 15
    stmlist                        shift and go to state 38
    exprl                          shift and go to state 18
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 129

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl . RBRACKET ASSIGN exprl SC
    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl . RBRACKET

    RBRACKET        shift and go to state 140


state 130

    (27) stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl . SC

    SC              shift and go to state 141


state 131

    (55) contexprllist -> COMMA exprl contexprllist .

    RPAREN          reduce using rule 55 (contexprllist -> COMMA exprl contexprllist .)


state 132

    (29) stmt -> IF LPAREN exprl RPAREN block ELSE . block
    (33) block -> . LCURLY stmlist RCURLY
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LCURLY          shift and go to state 115
    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 18
    block                          shift and go to state 142
    stmt                           shift and go to state 116
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 133

    (18) cont -> COMMA ID cont .

    RPAREN          reduce using rule 18 (cont -> COMMA ID cont .)


state 134

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY . stmlist RETURN exprl SC RCURLY
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    stmlist                        shift and go to state 143
    exprl                          shift and go to state 18
    stmt                           shift and go to state 15
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 135

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY . stmlist RETURN SC RCURLY
    (20) stmlist -> . stmt stmlist
    (21) stmlist -> . stmt
    (22) stmt -> . PRINTI LPAREN exprl RPAREN SC
    (23) stmt -> . PRINTLN LPAREN RPAREN SC
    (24) stmt -> . PRINTS LPAREN STRING RPAREN SC
    (25) stmt -> . WHILE LPAREN exprl RPAREN block
    (26) stmt -> . ID ASSIGN exprl SC
    (27) stmt -> . ID LBRACKET exprl RBRACKET ASSIGN exprl SC
    (28) stmt -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC
    (29) stmt -> . IF LPAREN exprl RPAREN block ELSE block
    (30) stmt -> . IF LPAREN exprl RPAREN block
    (31) stmt -> . INPUT LPAREN RPAREN SC
    (32) stmt -> . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    PRINTI          shift and go to state 16
    PRINTLN         shift and go to state 19
    PRINTS          shift and go to state 20
    WHILE           shift and go to state 21
    ID              shift and go to state 22
    IF              shift and go to state 23
    INPUT           shift and go to state 24
    LPAREN          shift and go to state 17
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    stmlist                        shift and go to state 144
    stmt                           shift and go to state 15
    exprl                          shift and go to state 18
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 136

    (11) dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET . SC

    SC              shift and go to state 145


state 137

    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl . RBRACKET

    RBRACKET        shift and go to state 146


state 138

    (33) block -> LCURLY stmlist RCURLY .

    PRINTI          reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    PRINTLN         reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    PRINTS          reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    WHILE           reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    ID              reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    IF              reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    INPUT           reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    LPAREN          reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    NUM             reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    NOT             reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    NEG             reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    ATOI            reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    TRUE            reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    FALSE           reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    $end            reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    RCURLY          reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    RETURN          reduce using rule 33 (block -> LCURLY stmlist RCURLY .)
    ELSE            reduce using rule 33 (block -> LCURLY stmlist RCURLY .)


state 139

    (34) block -> LCURLY stmt RCURLY .

    PRINTI          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    PRINTLN         reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    PRINTS          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    WHILE           reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    ID              reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    IF              reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    INPUT           reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    LPAREN          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    NUM             reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    NOT             reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    NEG             reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    ATOI            reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    TRUE            reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    FALSE           reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    $end            reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    RCURLY          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    RETURN          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    ELSE            reduce using rule 34 (block -> LCURLY stmt RCURLY .)


state 140

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET . ASSIGN exprl SC
    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .

    ASSIGN          shift and go to state 147
    MULT            reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    DIV             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    EQ              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    GEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    LEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    LT              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    GT              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    NEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    AND             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    OR              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    ADD             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    SUBT            reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    SC              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)


state 141

    (27) stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .

    PRINTI          reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    PRINTLN         reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    PRINTS          reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    WHILE           reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ID              reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    IF              reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    INPUT           reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    LPAREN          reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NUM             reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NOT             reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NEG             reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ATOI            reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    TRUE            reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    FALSE           reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    $end            reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    RCURLY          reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    RETURN          reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ELSE            reduce using rule 27 (stmt -> ID LBRACKET exprl RBRACKET ASSIGN exprl SC .)


state 142

    (29) stmt -> IF LPAREN exprl RPAREN block ELSE block .

    PRINTI          reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    PRINTLN         reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    PRINTS          reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    WHILE           reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    ID              reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    IF              reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    INPUT           reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    LPAREN          reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    NUM             reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    NOT             reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    NEG             reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    ATOI            reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    TRUE            reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    FALSE           reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    $end            reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    RCURLY          reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    RETURN          reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)
    ELSE            reduce using rule 29 (stmt -> IF LPAREN exprl RPAREN block ELSE block .)


state 143

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist . RETURN exprl SC RCURLY

    RETURN          shift and go to state 148


state 144

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist . RETURN SC RCURLY

    RETURN          shift and go to state 149


state 145

    (11) dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .

    INT             reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    DEF             reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    PRINTI          reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    PRINTLN         reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    PRINTS          reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    WHILE           reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    ID              reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    IF              reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    INPUT           reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    LPAREN          reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    NUM             reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    NOT             reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    NEG             reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    ATOI            reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    TRUE            reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    FALSE           reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)
    $end            reduce using rule 11 (dec_mat -> INT ID LBRACKET NUM RBRACKET LBRACKET NUM RBRACKET SC .)


state 146

    (48) factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .

    MULT            reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    DIV             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    RPAREN          reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    ADD             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    SUBT            reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    EQ              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    GEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    LEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    LT              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    GT              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    NEQ             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    AND             reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    OR              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    SC              reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    RBRACKET        reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)
    COMMA           reduce using rule 48 (factor -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET .)


state 147

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN . exprl SC
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 150
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 148

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN . exprl SC RCURLY
    (36) exprl -> . expr oprl exprl
    (37) exprl -> . expr
    (38) expr -> . expr opra term
    (39) expr -> . term
    (40) term -> . term oprm factor
    (41) term -> . factor
    (42) factor -> . LPAREN expr RPAREN
    (43) factor -> . ID
    (44) factor -> . NUM
    (45) factor -> . NOT exprl
    (46) factor -> . NEG exprl
    (47) factor -> . ID LBRACKET exprl RBRACKET
    (48) factor -> . ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET
    (49) factor -> . ATOI LPAREN argatoi RPAREN
    (50) factor -> . ID LPAREN exprllist RPAREN
    (51) factor -> . TRUE
    (52) factor -> . FALSE

    LPAREN          shift and go to state 17
    ID              shift and go to state 41
    NUM             shift and go to state 28
    NOT             shift and go to state 29
    NEG             shift and go to state 30
    ATOI            shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    exprl                          shift and go to state 151
    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 149

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN . SC RCURLY

    SC              shift and go to state 152


state 150

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl . SC

    SC              shift and go to state 153


state 151

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl . SC RCURLY

    SC              shift and go to state 154


state 152

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC . RCURLY

    RCURLY          shift and go to state 155


state 153

    (28) stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .

    PRINTI          reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    PRINTLN         reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    PRINTS          reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    WHILE           reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ID              reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    IF              reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    INPUT           reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    LPAREN          reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NUM             reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NOT             reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    NEG             reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ATOI            reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    TRUE            reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    FALSE           reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    $end            reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    RCURLY          reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    RETURN          reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)
    ELSE            reduce using rule 28 (stmt -> ID LBRACKET exprl RBRACKET LBRACKET exprl RBRACKET ASSIGN exprl SC .)


state 154

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC . RCURLY

    RCURLY          shift and go to state 156


state 155

    (15) fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .

    DEF             reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    PRINTI          reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    PRINTLN         reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    PRINTS          reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    WHILE           reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    ID              reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    IF              reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    INPUT           reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    LPAREN          reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    NUM             reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    NOT             reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    NEG             reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    ATOI            reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    TRUE            reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    FALSE           reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)
    $end            reduce using rule 15 (fun -> DEF ID LPAREN idlist RPAREN VOID LCURLY stmlist RETURN SC RCURLY .)


state 156

    (14) fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .

    DEF             reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    PRINTI          reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    PRINTLN         reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    PRINTS          reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    WHILE           reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    ID              reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    IF              reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    INPUT           reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    LPAREN          reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    NUM             reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    NOT             reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    NEG             reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    ATOI            reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    TRUE            reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    FALSE           reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)
    $end            reduce using rule 14 (fun -> DEF ID LPAREN idlist RPAREN INT LCURLY stmlist RETURN exprl SC RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ in state 25 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 25 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 25 resolved as shift
WARNING: shift/reduce conflict for LT in state 25 resolved as shift
WARNING: shift/reduce conflict for GT in state 25 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 25 resolved as shift
WARNING: shift/reduce conflict for AND in state 25 resolved as shift
WARNING: shift/reduce conflict for OR in state 25 resolved as shift
WARNING: shift/reduce conflict for ADD in state 25 resolved as shift
WARNING: shift/reduce conflict for SUBT in state 25 resolved as shift
WARNING: shift/reduce conflict for MULT in state 26 resolved as shift
WARNING: shift/reduce conflict for DIV in state 26 resolved as shift
WARNING: shift/reduce conflict for MULT in state 84 resolved as shift
WARNING: shift/reduce conflict for DIV in state 84 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 120 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 128 resolved as shift
